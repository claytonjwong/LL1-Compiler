//////////////////////////////////////////////////////////////
//
// programmers: Jose Gifford and Clayton Wong
// description: a top-down left, factored,
// left to right parser with 1
// token of lookahead -- a LL(1) parser for
// the language MINI_L
//
//////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////
// header files
//
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <lexErrorList.h>
#include <linkedlist.h>
#include <lex.h>
#include <parse.h>
#include <gen.h>
//////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////
// function declarations
//
static void Usage();
//////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////
// main
//
int main(int argc, char *argv[])
{
	Bool printProd = FALSE;
	Bool printSource = FALSE;
	Bool printTokens = FALSE;
	Bool printParseTable = FALSE;
	Bool printSymbolTable = FALSE;
	Bool printIntrCode = FALSE;

	char c;

	while ((c = getopt(argc, argv, "ahpstlyi")) != -1)
	{
		switch(c)
		{
			case 'a':
				printProd = TRUE;
				printSource = TRUE;
				printTokens = TRUE;
				printParseTable = TRUE;
				printSymbolTable = TRUE;
				printIntrCode = TRUE;
				break;

			case 'h':
				Usage();
				return 0;

			case 'p':
				printProd = TRUE;
				break;

			case 's':
				printSource = TRUE;
				break;

			case 't':
				printTokens = TRUE;
				break;
			case 'l':
				printParseTable = TRUE;
				break;

			case 'y':
				printSymbolTable = TRUE;
				break;

			case 'i':
				printIntrCode = TRUE;
				break;

			case '?':
				Usage();
				return 0;

			default:
				Error("Main Internal Error.\n");
				break;
		}

	}


	////////////////////////////////////////
	//
	// print the program source code (input file stream)
	//
	if (printSource == TRUE)
	{
		////////////////////////////////////////
		// open input file (MINI_L source code)
		//
		FILE* inFile = NULL;

		if (optind == argc - 1) // then there is an extra argument
		{
			inFile = fopen(argv[argc - 1], "r");

			if (inFile == NULL)
				Error("Unable to open input file.\n");
		}

		else
		{
			printf("\n\nPlease enter valid command line argument(s)...\n");
			Usage();
			return 0;
		}

		printf("\n\n -- MINI_L source code\n\n");
		lexErrorPrintList(inFile);
		fclose(inFile);
	}
	////////////////////////////////////////


	////////////////////////////////////////
	// open input file (MINI_L source code)
	//
	FILE* inFile = NULL;

	if (optind == argc - 1) // then there is an extra argument
	{
		inFile = fopen(argv[argc - 1], "r");

		if (inFile == NULL)
			Error("Unable to open input file.\n");
	}

	else
	{
		printf("\n\nPlease enter valid command line argument(s)...\n");
		Usage();
		return 0;
	}
	////////////////////////////////////////


	////////////////////////////////////////
	// perform lexical analysis upon input file
	//
	InitializeLexicalAnalysis(inFile);

	fclose(inFile);
	inFile = fopen(argv[argc - 1], "r");
	if (inFile == NULL)
		Error("Unable to open input file.\n");

	if (printProd == TRUE)
		printf("\n\n-- MINI_L grammar productions\n\n");

	EngageParse(inFile, printTokens, printProd,	printSymbolTable);
	fclose(inFile);
	////////////////////////////////////////


	////////////////////////////////////////
	//
	// print parse table
	//
	if (printParseTable == TRUE)
	{
		printf("\n\n -- parse table for LL(1) parser\n\n");
		PrintParseTable();
	}

	////////////////////////////////////////
	//
	// print the list of tokens generated by the lexical analyzer
	//
	if (printTokens == TRUE)
	{
		fprintf(stdout,"\n\n-- list of tokens generated by the lexical analyzer\n\n");
		PrintList();
	}

	////////////////////////////////////////
	//
	// print the intermediate code generated by
	// the sematic rules
	//
	if (printIntrCode == TRUE)
	{
		char* fileName = strtok(argv[argc -1], ".");
		char* icFileName = (char*)malloc(sizeof(strlen(fileName) + 6));

		icFileName = strcat(fileName, OUTPUT_EXTENSION);

		inFile = fopen(icFileName, "r");

		char buf = getc(inFile);

		while(buf != EOF)
		{
			printf("%c", buf);
			buf = getc(inFile);
		}
	}

	return 0;
}
//
// end main
//////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////
//
// Usage(void)
//
// prints the valid command line option's for
// executable "tisc"
//
static void Usage(void)
{
	printf("\n\nUsage  : jcc [-a] [-h] [-p] [-s] [-t] [-l] [-y] [-i] input\n");
	printf("\nOptions:\n");
	printf("\t-h\t\t\thelp, which prints this usage message.\n");
	printf("\t-a\t\t\tprint all (source code, tokens, prodctions).\n");
	printf("\t-p\t\t\tprint productions.\n");
	printf("\t-s\t\t\tprint source code.\n");
	printf("\t-t\t\t\tprint tokens.\n");
	printf("\t-l\t\t\tprint parse table.\n");
	printf("\t-y\t\t\tprint symbol table.\n");
	printf("\t-i\t\t\tprint intermediate code.\n");
	printf("\tinput\t\t\tthe MINI_L code input file.\n\n\n");

}
//
// end Usage(void) function
//////////////////////////////////////////////////////////////
